/*
 * Copyright (C) 2015 Jens Bertram (code@jens-bertram.net)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*******************************************************************************
 * General configuration.
 */
/**
 * Location to store any working-data.
 */
ext.workingDirectory = new File('data')

ext.conf = [:]
/**
 * Target directories.
 */
ext.conf.targets = [
        index                 : '/data/clef/Clarity/work/fiz/index/',
        ipcDump               : workingDirectory.absolutePath + '/ipcStats',
        plots                 : workingDirectory.absolutePath + '/plots',
        scoring               : workingDirectory.absolutePath + '/scoring',
        termDump              : workingDirectory.absolutePath + '/termDump',
        termDumpSample        : workingDirectory.absolutePath +
                '/termDumpSample',
        termDumpSampleSentence: workingDirectory.absolutePath +
                '/termDumpSampleSentence'
]

/**
 * GNU R configuration.
 */
ext.conf.r = [
        scriptPath: 'rscripts'
]

/**
 * Java runtime configuration.
 */
ext.conf.java = [
        /**
         * Default Java package.
         */
        package  : 'de.unihildesheim.iw.',
        /**
         * Java ClassPath to use.
         */
        classPath: files('target/QueryClarity.jar')
]

/**
 * Stopwords configuration.
 */
ext.conf.stopwords = [
        /**
         * Location of stopword files.
         */
        pathPattern: new File('stop/stop/').absolutePath,
        /**
         * Default stopwords file format.
         */
        format     : 'snowball'
]

/**
 * Scoring configuration.
 */
ext.conf.scoring = [
        /**
         * Languages available for scoring.
         */
        languages: ['de', 'en', 'fr'],
        /**
         * Lucene fields available for scoring.
         */
        fields   : ['claims', 'detd']
]

ext.conf.ipc = [
        /**
         * List of all known IPC-section identifiers.
         */
        sections    : ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'],
        /**
         * Char to use for separating main- and sub-group.
         */
        grpSeparator: '-'
]

ext.TaskConf = [:]

/*******************************************************************************
 * Internal configuration.
 */
/**
 * Pre-defined task group-names.
 */
ext.groupNames = [
        intern         : 'Internal',
        termDump       : 'Term-frequency data dumps: ' +
                "Base data (${conf.targets.termDump})",
        termDumpIpc    : 'Term frequency data dumps: ' +
                "Filtered by IPC-section (${conf.targets.termDump})",
        extractTerms   : 'Sample terms from term-frequency data dumps: ' +
                "Base data (${conf.targets.termDumpSample})",
        extractTermsIpc: 'Sample terms from term-frequency data dumps: ' +
                "Filtered by IPC-section (${conf.targets.termDumpSample})",
        index          : 'Lucene index related tasks',
        dumpIpcStats   : "Dump IPC-Data statistics (${conf.targets.ipcDump})",
        plot           : "Data plotting (${conf.targets.plots})",
        getSentences   : "Get sentences from TermFreq dump terms " +
                "(${conf.targets.termDumpSampleSentence})"
]

/*******************************************************************************
 * Utilities
 */
ext.Validate = [
        requireFile    : { f ->
            if (!f.exists()) {
                logger.error("Check for file ${f} - failed.")
                throw new IllegalStateException(
                        "Required file ${f} does not exist.")
            }
            logger.info("Check for file ${f} - Ok.")
        },

        deleteIfPresent: { f ->
            if (f.exists()) {
                logger.info("Delete ${f} - since it's out of date.")
                f.delete()
            }
        }
]

/**
 * Parse the set of parameters passed to pattern based tasks.
 * @param dataString Parameter string
 * @return Parsed values from parameter string
 */
def parseDataSuffix(dataString) {
    if (dataString.startsWith('-')) {
        dataString = dataString - '-'
    }

    def params = [:]
    if (dataString.length() > 0) {
        params._list = dataString.split('-')
        if (params._list.length >= 1) {
            params.language = params._list[0].toLowerCase()
            if (!conf.scoring.languages.contains(params.language)) {
                throw new IllegalArgumentException(
                        "Unknown language '${params.language}'.")
            }
        }
        if (params._list.length >= 2) {
            params.field = params._list[1].toLowerCase()
            if (!conf.scoring.fields.contains(params.field)) {
                throw new IllegalArgumentException(
                        "Unknown field '${params.field}'.")
            }
        }
        if (params._list.length >= 3) {
            params.ipcSec = params._list[2].toUpperCase()
            if (!conf.ipc.sections.contains(params.ipcSec)) {
                throw new IllegalArgumentException(
                        "Unknown IPC-Section '${params.ipcSec}'.")
            }
        }
    }
    params
}

/*******************************************************************************
 * Internal tasks.
 */
/**
 * Gradle wrapper task.
 */
task('wrapper', type: Wrapper) {
    description 'Create gradle wrapper for distribution.'
    group groupNames.intern
    gradleVersion = '2.3'
}

/**
 * Prepare the output directory.
 */
task('prepareOutput') {
    workingDirectory.mkdirs()
}

// include sub-tasks
apply from: 'gradle/task_termDump.gradle'
apply from: 'gradle/task_termDumpSample.gradle'
apply from: 'gradle/task_getSentences.gradle'
apply from: 'gradle/task_ipcStats.gradle'
apply from: 'gradle/task_plot.gradle'
apply from: 'gradle/task_score.gradle'

task(all) {
    description 'Run all tasks'
    dependsOn 'buildIndex-de', 'buildIndex-en', 'buildIndex-fr',
            TaskConf.TermDump.taskPrefix,
            TaskConf.TermDumpSample.taskPrefix,
            TaskConf.GetSentences.taskPrefix,
            TaskConf.Score.taskPrefix,
            TaskConf.IpcStats.taskPrefix,
            TaskConf.Plots.taskPrefix
}

/*******************************************************************************
 * Index building tasks.
 */
for (lang in conf.scoring.languages) {
    task("buildIndex-${lang}") {
        /**
         * Arguments for the main class.
         */
        def cmdArgs = [
                '-data', conf.targets.index,
                '-only-lang', lang,
                '-stop', conf.stopwords.pathPattern,
                '-stop-format', conf.stopwords.format]

        /**
         * Main class to execute from the generated tasks.
         */
        def mainClass = conf.java.package + 'fiz.cli.BuildIndex'

        group groupNames.index
        description "Create index. lang=${lang}."
        dependsOn prepareOutput
        outputs.files conf.targets.index + lang + '/'

        doLast {
            logger.info("Building index for language=${lang}")

            javaexec {
                args = cmdArgs
                classpath = conf.java.classPath
                main = mainClass
            }
        }
    }
}

task('buildIndex') {
    def depTasks = []
    for (lang in conf.scoring.languages) {
        depTasks.add(tasks["buildIndex-${lang}"])
    }

    group groupNames.index
    description 'Batch create index. lang=*.'
    dependsOn depTasks
}