/*
 * Copyright (C) 2015 Jens Bertram (code@jens-bertram.net)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// Scoring tasks.

TaskConf.Score = [
        /**
         * Database file name prefix.
         */
        dbPrefix  : 'score',
        /**
         * Task name prefix
         */
        taskPrefix: 'score']
/**
 * Create a target database file name.
 * @param lang Language
 * @param field Lucene field
 * @param ipc IPC-Code (optional)
 * @return Filename String
 */
TaskConf.Score.createDBFileName = { lang, field, ipc ->
    return "${TaskConf.Score.dbPrefix}-${lang}_${field}" +
            (ipc == null ? '' : "-ipc_${ipc.toLowerCase()}") + '.sqlite'
}

/*******************************************************************************
 * Tasks
 */
tasks.addRule("Pattern (${TaskConf.Score.taskPrefix}): " +
        'Score terms & sentences.\n' +
        "  * ${TaskConf.Score.taskPrefix}: " +
        'all languages, fields, IPC\n' +
        "  * ${TaskConf.Score.taskPrefix}-<LANGUAGE>: " +
        'only <LANGUAGE>, all fields, IPC\n' +
        "  * ${TaskConf.Score.taskPrefix}-<LANGUAGE>-<FIELD>: " +
        'only <LANGUAGE> and <FIELD>, all IPC\n' +
        "  * ${TaskConf.Score.taskPrefix}-<LANGUAGE>-<FIELD>-<IPC-SECTION>: " +
        'only <LANGUAGE>, <FIELD>, <IPC>') {
    String taskName ->
        if (taskName.startsWith(TaskConf.Score.taskPrefix)) {
            task(taskName) {
                /**
                 * Runtime parameters derived from task name.
                 */
                ext.params = parseDataSuffix(
                        taskName - TaskConf.Score.taskPrefix)
                /**
                 * If true, this task will not execute any Java task.
                 */
                ext.noAction = params.language == null || params.field == null

                if (!noAction) {
                    /**
                     * Source file with picked terms.
                     */
                    ext.source = [
                            fileName: TaskConf.GetSentences.createDBFileName(
                                    params.language, params.field,
                                    params.ipcSec),
                            path    : conf.targets.termDumpSampleSentence]
                    ext.source.file = file(new File(
                            "${ext.source.path}/${ext.source.fileName}"))
                    /**
                     * Target file with picked terms and sentences.
                     */
                    ext.target = [
                            fileName: TaskConf.Score.createDBFileName(
                                    params.language, params.field,
                                    params.ipcSec),
                            path    : conf.targets.scoring]
                    ext.target.file = file(new File(
                            "${ext.target.path}/${ext.target.fileName}"))
                }

                dependsOn {
                    def depTasks = ['prepareOutput']
                    def suffix = ""

                    if (params.language == null) {
                        for (lang in conf.scoring.languages) {
                            for (field in conf.scoring.fields) {
                                suffix = '-' + lang + '-' + field
                                depTasks.add(tasks[TaskConf.Score
                                        .taskPrefix + suffix])
                                depTasks.add(tasks[TaskConf.GetSentences
                                        .taskPrefix + suffix])
                                for (ipcSec in conf.ipc.sections) {
                                    suffix = '-' + lang + '-' +
                                            field + '-' + ipcSec
                                    depTasks.add(tasks[TaskConf.Score
                                            .taskPrefix + suffix])
                                    depTasks.add(tasks[TaskConf.GetSentences
                                            .taskPrefix + suffix])
                                }
                            }
                        }
                    } else if (params.field == null) {
                        for (field in conf.scoring.fields) {
                            suffix = '-' + params.language + '-' + field
                            depTasks.add(tasks[TaskConf.Score
                                    .taskPrefix + suffix])
                            depTasks.add(tasks[TaskConf.GetSentences
                                    .taskPrefix + suffix])
                            for (ipcSec in conf.ipc.sections) {
                                suffix = '-' + params.language + '-' +
                                        field + '-' + ipcSec
                                depTasks.add(tasks[TaskConf.Score
                                        .taskPrefix + suffix])
                                depTasks.add(tasks[TaskConf.GetSentences
                                        .taskPrefix + suffix])
                            }
                        }
                    } else if (params.ipcSec == null) {
                        // avoid circular dependency
                        suffix = '-' + params.language + '-' + params.field
                        def depTask = TaskConf.Score.taskPrefix + suffix
                        if (name != depTask) {
                            depTasks.add(tasks[depTask])
                        }

                        depTasks.add(tasks[TaskConf.GetSentences
                                .taskPrefix + suffix])
                        for (ipcSec in conf.ipc.sections) {
                            suffix = '-' + params.language + '-' +
                                    params.field + '-' + ipcSec
                            depTasks.add(tasks[TaskConf.Score
                                    .taskPrefix + suffix])
                            depTasks.add(tasks[TaskConf.GetSentences
                                    .taskPrefix + suffix])
                        }
                    } else {
                        suffix = '-' + params.language + '-' +
                                params.field + '-' + params.ipcSec
                        depTasks.add(tasks[TaskConf.GetSentences
                                .taskPrefix + suffix])
                    }
                    depTasks
                }

                outputs.files {
                    if (noAction) {
                        return;
                    }
                    target.file
                }

                doLast {
                    if (noAction) {
                        return;
                    }

                    /**
                     * Main class to execute from the generated tasks.
                     */
                    ext.mainClass = conf.java.package + 'fiz.cli.Score'
                    /**
                     * Command-line arguments for the main class.
                     */
                    ext.cmdArgs = [
                            '-fields', params.field,
                            '-idx', conf.targets.index + params.language,
                            '-lang', params.language,
                            '-scoredb', ext.target.file.toString()]

                    // check, if source exists
                    Validate.requireFile(source.file)

                    // delete target DB, if present
                    Validate.deleteIfPresent(target.file)

                    // create target directory
                    new File(ext.target.path.toString()).mkdirs()

                    copy {
                        from source.file
                        into target.path
                        include source.fileName
                    }

                    file("${target.path}/${source.fileName}")
                            .renameTo(file(target.file))

                    // run java
                    javaexec {
                        args = cmdArgs
                        classpath = conf.java.classPath
                        main = mainClass
                    }

                    // check, if output is present
                    Validate.requireFile(target.file)
                }
            }
        }
}